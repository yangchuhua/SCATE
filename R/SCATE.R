#' Perform SCATE
#'
#' Single-cell ATAC-seq signal Extration and Enhancement
#'
#' This function takes as input the scATAC-seq reads and generates enhanced signals.
#' @param satac GRanges object or list of GRanges object of scATAC-seq reads. The GRanges should be the middle point of the reads with length of 1 base pair. Use 'satacprocess' to preprocess raw reads.
#' @param genome Character variable of either "hg19" or "mm10". Default is 'hg19'.
#' @param datapath Character variable of the path to the customized database (eg myfolder/database.rds). The database can be made using 'makedatabase' function. If not null, 'genome' is ignored.
#' @param ncores Numeric variable of number of cores to use. If NULL, the maximum number of cores is used.
#' @return A numeric vector of values generated by SCATE. The length of the vector is the same as the number of bins in the genome.
#' @export
#' @import GenomicAlignments parallel splines2 xgboost
#' @author Zhicheng Ji, Weiqiang Zhou, Hongkai Ji <zji4@@zji4.edu>
#' @examples
#' SCATE(GRanges(seqnames="chr1",IRanges(start=1:100+1e6,end=1:100+1e6)),genome="hg19")

SCATE <- function(satac,genome='hg19',datapath=NULL,ncores=detectCores()) {
      options(scipen=999)
      set.seed(12345)
      if (!is.null(datapath)) {
        loaddata <- readRDS(datapath)
      } else {
        loaddata <- readRDS(paste0(system.file(package="SCATE"),"/extdata/",genome,".rds"))
      }
      allclunum <- loaddata$allclunum
      ms <- loaddata$ms
      m <- ms$m
      s <- ms$s
      id <- loaddata$id
      gr <- loaddata$gr
      satac <- unlist(GRangesList(satac))
      count <- countOverlaps(gr[id],satac)
      
      cutm <- as.numeric(cut(m,quantile(m,c(0:10)/10),include.lowest = T))
      hkid <- unlist(sapply(unique(cutm),function(i) {
            tmpid <- which(cutm==i)
            tmpid[which(s[tmpid] <= sort(s[tmpid])[1000])]
      }))
      
      mfit <- function(x,y) {
            tryid <- 0:5
            BIC <- rep(0,length(tryid))
            fit <- allkn <- list()
            for (knotid in 1:length(tryid)) {
                  knotnum <- tryid[knotid]
                  if (knotnum==0) {
                        knots <- NULL
                  } else {
                        knots <- quantile(x,seq(0,1,length.out=knotnum+2)[-c(1,knotnum+2)])
                  }
                  base <- cbind(1,iSpline(x,knots=knots,Boundary.knots=range(x)))
                  allkn[[knotid]] <- knots
                  optimfunc <- function(k) {
                        logmu <- (base %*% matrix(k,ncol=1))[,1]
                        -sum(y*logmu-exp(logmu))
                  }
                  fit[[knotid]] <- optim(rep(1,ncol(base)),optimfunc,lower=c(-Inf,rep(0,ncol(base)-1)),method="L-BFGS-B")
                  logmu <- (base %*% matrix(fit[[knotid]]$par,ncol=1))[,1]
                  BIC[knotid] <- log(length(y))*length(fit[[knotid]]$par)-2*sum(y*logmu-exp(logmu))
            }
            par <- fit[[which.min(BIC)]]$par
            knots <- allkn[[which.min(BIC)]]
            xseq <- seq(min(x),max(x),0.005)
            base <- cbind(1,iSpline(xseq,knots=knots,Boundary.knots=range(x)))
            logmu <- (base %*% matrix(par,ncol=1))[,1]
            
            slopeleft <- (logmu[length(xseq)*0.1] - logmu[1])/(xseq[length(xseq)*0.1] - xseq[1])
            sloperight <- (logmu[length(xseq)] - logmu[length(xseq)*0.9])/(xseq[length(xseq)] - xseq[length(xseq)*0.9])
            interleft <- logmu[1] - slopeleft*xseq[1]
            interright <- logmu[length(xseq)] - sloperight*xseq[length(xseq)]
            list(xseq = xseq, logmu = logmu, parleft = c(interleft,slopeleft), parright = c(interright,sloperight))
      }
      
      mfitres <- mfit(m[hkid],count[hkid])
      
      logmufunc <- function(x) {
            id <- round((x-min(mfitres$xseq))*200) + 1
            res <- rep(0,length(id))
            sid <- which(id >= 1 & id <= length(mfitres$xseq))
            res[sid] <- mfitres$logmu[id[sid]]
            sid <- which(id < 1)
            res[sid] <- mfitres$parleft[1] + mfitres$parleft[2] * x[sid]
            sid <- which(id > length(mfitres$logmu))
            res[sid] <- mfitres$parright[1] + mfitres$parright[2] * x[sid]
            res
      }
      
      # smoothScatter(m[hkid],count[hkid],xlim=c(-10,10))
      # lines(seq(-10,10,0.01),exp(sapply(seq(-10,10,0.01),logmufunc)),col="red")
      
      deltafitfunc <- function(count,m,s) {
            if (length(count) == 1) {
                  if (count == 0) {
                        optimfunc <- function(delta) {
                              exp(logmufunc(m+s*delta)) + delta^2/2
                        }
                  } else {
                        optimfunc <- function(delta) {
                              logmu <- logmufunc(m+s*delta)
                              -(count*logmu-exp(logmu)) + delta^2/2
                        }
                  }
            } else {
                  if (sum(count) == 0) {
                        optimfunc <- function(delta) {
                              sum(exp(logmufunc(m+s*delta))) + delta^2/2
                        }
                  } else {
                        optimfunc <- function(delta) {
                              logmu <- logmufunc(m+s*delta)
                              -sum(count*logmu-exp(logmu)) + delta^2/2
                        }
                  }
            }
            optimise(optimfunc,c(-100,100))$minimum 
      }
      
      clunum <- NULL
      if (is.null(clunum)) {
            cluster <- loaddata$cluster[,ncol(loaddata$cluster)]
            spclu <- split(1:length(cluster),cluster)
            tabclu <- sapply(spclu,length)
            targetcluid <- which(tabclu >= 10)
            targetid <- unlist(spclu[targetcluid])
            if (length(targetid) > 10000) {
                  set.seed(12345)
                  targetid <- sample(targetid,10000) 
            }
            loglike <- sapply(allclunum,function(clunum) {
                  cluster <- loaddata$cluster[,which(allclunum==clunum)]
                  spclu <- split(1:length(cluster),cluster)
                  names(spclu) <- NULL
                  loglike <- unlist(mclapply(targetid,function(testid) {
                        trainid <- setdiff(spclu[[cluster[testid]]],testid)
                        delta <- deltafitfunc(count[trainid],m[trainid],s[trainid])
                        logmu <- logmufunc(m[testid]+s[testid]*delta)
                        count[testid]*logmu-exp(logmu)
                  },mc.cores=ncores))
            })
            logclu <- log2(c(allclunum,length(id)))
            medll <- apply(loglike,2,median)
            loessmod <- loess(medll~logclu,data.frame(medll=medll,logclu=logclu[-length(logclu)]),surface="direct")
            clunum <- allclunum[which.max(predict(loessmod,logclu))]
      }
      returnclunumonly <- F
      if (returnclunumonly) {
            clunum
      } else {
      if (clunum == length(id)) {
            crefeature <- unlist(mclapply(1:length(id),function(i) {
                  m[i]+s[i]*deltafitfunc(count[i],m[i],s[i])
            },mc.cores=ncores))
      } else {
            cluster <- loaddata$cluster[,which(allclunum==clunum)]
            spclu <- split(1:length(cluster),cluster)
            delta <- unlist(mclapply(1:clunum,function(cluid) {
                  binid <- spclu[[cluid]]
                  deltafitfunc(count[binid],m[binid],s[binid])
            },mc.cores=ncores))
            crefeature <- m+s*delta[cluster]
      }
      returncreonly <- F
      if (returncreonly) {
            pmax(0,crefeature)
      } else {
            excid <- loaddata$excid
            excms <- loaddata$excms
            excm <- excms$m
            excs <- excms$s
            exccount <- countOverlaps(gr[excid],satac)
            logcount <- log2(count + 1)
            logexccount <- log2(exccount + 1)
            
            mod <- xgboost(cbind(m=m,logcount=logcount,s=s),crefeature,nrounds=50,verbose=F)
            predfeature <- predict(mod,cbind(m=excm,logcount=logexccount,s=excs))
            fullfeature <- rep(0,length(gr))
            fullfeature[id] <- crefeature
            fullfeature[excid] <- predfeature
            pmax(0,fullfeature)
      }
      }
}

