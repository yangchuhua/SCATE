#' Peak calling
#'
#' Peak calling function 
#'
#' This function performs peak calling for signal generated by SCATE
#' @param feature Feature generated by SCATE.
#' @param genome Character variable of either "hg19" or "mm10". Should be the same as that used in SCATE function.
#' @param flank Numeric variable of the number of flanking bins for each bin. For each bin, an averaged signal of itself and the flanking bins will be calculated and compared to a background distribution.
#' @param fdrcut Numeric variable of FDR cutoff. Bins passing the FDR cutoff will be peaks.
#' @return A list of three components: GenomicRanges of peak regions, FDR for peaks and peak signals.
#' @export
#' @import GenomicRanges
#' @author Zhicheng Ji, Weiqiang Zhou, Hongkai Ji <zji4@@zji4.edu>
#' @examples
#' peakcall(SCATE(GRanges(seqnames="chr1",IRanges(start=1:100+1e6,end=1:100+1e6)),genome="hg19"))

peakcall <- function(feature,genome,flank=1,fdrcut=1e-5) {
      set.seed(12345)
      loaddata <- readRDS(paste0(system.file(package="SCATE"),"/extdata/",genome,".rds"))
      gr <- loaddata$gr
      flankgr <- gr
      start(flankgr) <- start(flankgr) - 200 * flank
      end(flankgr) <- end(flankgr) + 200 * flank
      flankgrover <- as.matrix(findOverlaps(gr,flankgr))
      
      sumv <- rowsum(feature[flankgrover[,1]],flankgrover[,2])[,1]
      sumv <- sumv/rowsum(rep(1,nrow(flankgrover)),flankgrover[,2])[,1]
      
      sampfeature <- sample(feature)
      backv <- sapply(0:100000,function(i) mean(sampfeature[(1+i*(2*flank+1)):((i+1)*(2*flank+1))]))
      xseq <- seq(floor(min(sumv)),ceiling(max(sumv)),0.1)
      fdr <- sapply(xseq,function(cut) {
            mean(backv >= cut)/mean(sumv >= cut)
      })
      fdr <- cummin(fdr)
      fdr <- approx(xseq[!is.na(fdr)],fdr[!is.na(fdr)],sumv,rule=2)$y
      sig <- which(fdr < fdrcut)
      centergr <- gr[sig]
      
      boundgr <- gr[unique(flankgrover[flankgrover[,2] %in% sig,1])]
      boundgr <- reduce(boundgr)
      over <- as.matrix(findOverlaps(centergr,boundgr))
      fdr <- tapply(fdr[sig][over[,1]],list(over[,2]),min)
      signal <- tapply(sumv[sig][over[,1]],list(over[,2]),max)
      list(gr=boundgr,fdr=fdr,signal=signal)
}

